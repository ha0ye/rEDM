% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/lnlp_interface.R
\name{simplex}
\alias{simplex}
\alias{s_map}
\alias{s_map}
\title{Perform univariate forecasting}
\usage{
simplex(time_series, lib = c(1, NROW(time_series)), pred = lib, norm = 2,
  E = 1:10, tau = 1, tp = 1, num_neighbors = "e+1", stats_only = TRUE,
  exclusion_radius = NULL, epsilon = NULL, silent = FALSE)

s_map(time_series, lib = c(1, NROW(time_series)), pred = lib, norm = 2,
  E = 1, tau = 1, tp = 1, num_neighbors = 0, theta = c(0, 1e-04,
  3e-04, 0.001, 0.003, 0.01, 0.03, 0.1, 0.3, 0.5, 0.75, 1, 1.5, 2, 3, 4, 6, 8),
  stats_only = TRUE, exclusion_radius = NULL, epsilon = NULL,
  silent = FALSE, save_smap_coefficients = FALSE)
}
\arguments{
\item{time_series}{either a vector to be used as the time series, or a 
data.frame or matrix with at least 2 columns (in which case the first 
column will be used as the time index, and the second column as the time 
series)}

\item{lib}{a 2-column matrix (or 2-element vector) where each row specifies 
the first and last *rows* of the time series to use for attractor 
reconstruction}

\item{pred}{(same format as lib), but specifying the sections of the time 
series to forecast.}

\item{norm}{the distance measure to use. see 'Details'}

\item{E}{the embedding dimensions to use for time delay embedding}

\item{tau}{the lag to use for time delay embedding}

\item{tp}{the prediction horizon (how far ahead to forecast)}

\item{num_neighbors}{the number of nearest neighbors to use. Note that the 
default value will change depending on the method selected. (any of "e+1", 
"E+1", "e + 1", "E + 1" will peg this parameter to E+1 for each run, any
value < 1 will use all possible neighbors.)}

\item{stats_only}{specify whether to output just the forecast statistics or 
the raw predictions for each run}

\item{exclusion_radius}{excludes vectors from the search space of nearest 
neighbors if their *time index* is within exclusion_radius (NULL turns 
this option off)}

\item{epsilon}{excludes vectors from the search space of nearest neighbors 
if their *distance* is farther away than epsilon (NULL turns this option 
off)}

\item{silent}{prevents warning messages from being printed to the R console}

\item{theta}{the nonlinear tuning parameter (theta is only relevant if 
method == "s-map")}

\item{save_smap_coefficients}{specifies whether to include the s_map 
coefficients with the output (and forces stats_only = FALSE, as well)}
}
\value{
For \code{\link{simplex}}, a data.frame with components for the 
  parameters and forecast statistics:
\tabular{ll}{
  \code{E} \tab embedding dimension\cr
  \code{tau} \tab time lag\cr
  \code{tp} \tab prediction horizon\cr
  \code{nn} \tab number of neighbors\cr
  \code{num_pred} \tab number of predictions\cr
  \code{rho} \tab correlation coefficient between observations and 
    predictions\cr
  \code{mae} \tab mean absolute error\cr
  \code{rmse} \tab root mean square error\cr
  \code{perc} \tab percent correct sign\cr
  \code{p_val} \tab p-value that rho is significantly greater than 0 using 
    Fisher's z-transformation\cr
  \code{const_rho} \tab same as \code{rho}, but for the constant predictor\cr
  \code{const_mae} \tab same as \code{mae}, but for the constant predictor\cr
  \code{const_rmse} \tab same as \code{rmse}, but for the constant predictor\cr
  \code{const_perc} \tab same as \code{perc}, but for the constant predictor\cr
  \code{const_p_val} \tab same as \code{p_val}, but for the constant predictor\cr
  \code{model_output} \tab data.frame with columns for the time index, 
    observations, predictions, and estimated prediction variance
    (if \code{stats_only == FALSE})\cr
}

For \code{\link{s_map}}, the same as for \code{\link{simplex}}, but 
  with additional columns:
\tabular{ll}{
  \code{theta} \tab the nonlinear tuning parameter\cr
  \code{smap_coefficients} \tab data.frame with columns for the s-map 
  coefficients (if \code{save_smap_coefficients == TRUE})\cr
  \code{smap_coefficient_covariances} \tab list of covariance matrices for 
  the s-map coefficients (if \code{save_smap_coefficients == TRUE})\cr
}
}
\description{
\code{\link{simplex}} uses time delay embedding on a single time 
  series to generate an attractor reconstruction, and then applies the 
  simplex projection algorithm to make forecasts.

\code{\link{s_map}} is similar to \code{\link{simplex}}, but uses the S-map 
  algorithm to make forecasts.
}
\details{
\code{\link{simplex}} is typically applied, and the embedding dimension 
varied, to find an optimal embedding dimension for the data. Thus, the 
default parameters are set so that passing a time series as the only 
argument will run over E = 1:10 (embedding dimension), using leave-one-out 
cross-validation over the whole time series, and returning just the forecast 
statistics.

\code{\link{s_map}} is typically applied, with fixed embedding dimension, and theta 
varied, to test for nonlinear dynamics in the data. Thus, the default 
parameters are set so that passing a time series as the only  argument will 
run over a default list of thetas (0, 0.0001, 0.0003, 0.001, 0.003, 0.01, 
0.03, 0.1, 0.3, 0.5, 0.75, 1.0, 1.5, 2, 3, 4, 6, and 8), using E = 1, 
leave-one-out cross-validation over the whole time series, and returning 
just the forecast statistics.

\code{norm = 2} (default) uses the "L2 norm", Euclidean distance:
  \deqn{distance(a,b) := \sqrt{\sum_i{(a_i - b_i)^2}}
    }{distance(a, b) := \sqrt(\sum(a_i - b_i)^2)}
\code{norm = 1} uses the "L1 norm", Manhattan distance:
  \deqn{distance(a,b) := \sum_i{|a_i - b_i|}
    }{distance(a, b) := \sum|a_i - b_i|}
Other values generalize the L1 and L2 norm to use the given argument as the 
  exponent, P, as:
  \deqn{distance(a,b) := \sum_i{(a_i - b_i)^P}^{1/P}
    }{distance(a, b) := (\sum(a_i - b_i)^P)^(1/P)}
}
\examples{
data("two_species_model")
ts <- two_species_model$x[1:200]
simplex(ts, lib = c(1, 100), pred = c(101, 200))

data("two_species_model")
ts <- two_species_model$x[1:200]
simplex(ts, stats_only = FALSE)
 
data("two_species_model")
ts <- two_species_model$x[1:200]
s_map(ts, E = 2)

data("two_species_model")
ts <- two_species_model$x[1:200]
s_map(ts, E = 2, theta = 1, save_smap_coefficients = TRUE)

}
