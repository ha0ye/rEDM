---
title: "Introduction to rEDM"
author: "Hao Ye"
date: "March 10, 2015"
output:
  html_document: 
    toc: true
    number_sections: true
    css: styles.css
---

# Introduction
This file is designed to serve as an introduction to **rEDM**, an R package for Empirical Dynamic Modeling (EDM).


# Installation
rEDM is an **Rcpp** package, meaning that it contains both **C++** and **R** code. Because the C++ code needs to be compiled prior to usage, we present several different options for obtaining and installing the rEDM package, depending on your familiarity with R's package system.  

rEDM is compatible with **R 3.1.0+**, and works on **Mac OS X 10.9+** or **Windows 7+ (32-bit or 64-bit)**. We have not tested it for **Linux**, but believe it should work without any problems by compiling from source.  

## Rcpp
rEDM requires **Rcpp (0.11.2+)** to be installed. Please follow the normal [instructions](http://www.cookbook-r.com/Basics/Installing_and_using_packages/) for package installation to install Rcpp before installing rEDM.  

## Precompiled Binary Version
Precompiled versions can be downloaded from the following Google Drive links. Please be sure to download the latest version (0.2.2 as of March 10, 2015).  
[Windows](https://drive.google.com/folderview?id=0B10pWFVNQ65gfmUxaWZhWlN0di1IR3ZnTU8yX3l2TnlQV29GUEE0RU5JclZkZG9fWlA0em8&usp=sharing)  
[Mac OS X](https://drive.google.com/folderview?id=0B10pWFVNQ65gbVc5S0Y3MXZCc28&usp=sharing)  

To install the precompiled binary package, use the following R command, replacing `***` with the name of the package file. (You will need to either give the complete path, or put the package file in R's working directory.)
```{r, eval = FALSE}
install.packages("***", type = "source", repos = NULL)
```

## Source Version
The raw source can be downloaded from my Github repository [here](https://github.com/ha0ye/rEDM). If you are familiar with using Git with Rstudio projects, you can go ahead and clone it. Otherwise, it is possible to install it using functions from the **devtools** package:
```{r, eval = FALSE}
library(devtools)
install_github("ha0ye/rEDM")
```

Note that this method requires **Git** to be installed, along with a **C++11** compiler, in addition to **Rcpp**.

# Examples

## Data Input

The **rEDM** functions are designed to accept data in common R data formats, namely vectors, matrices, and data.frames. Depending on the specific function, one or the other data type is preferred. Please see the documentation associated with individual functions for more details.

## General Parameters

Many of the functions in **rEDM** are designed around the same prediction engine, and so share many of the following parameters. Please see the documentation associated with individual functions to verify which parameters are applicable as well as the default values (which can change from function to function)

* lib
    + a 2-column matrix (or 2-element vector) where each row specifies the portions of the time series to use for attractor reconstruction (i.e., the set of vectors that can be selected as nearest neighbors)
    + e.g., `(1, n)` specifies that the first n *rows* (from 1 to n) of data are a contiguous time series block, and can be used
    + by default, lib uses the entire input as a single contiguous segment
* pred
    + (same format as lib, but specifes the portions of the time series to make predictions for)
* norm_type
    + `"L2 norm"` (default) or `"L1 norm"`: specifies which distance metric to use when doing calculations
* E
    + the embedding dimension to use for attractor reconstruction
* tau
    + the lag to use for attractor reconstruction
    + by default, tau is set to `1`
* tp
    + the prediction horizon (how many steps ahead to make forecasts)
    + (negative values will also work)
* num_neighbors
    + the number of neighbors to use
    + `"e+1"`, `"E+1"`, `"e + 1"`, and `"E + 1"` will all peg this parameter to be `E+1` for each run
    + values less than 1 will use all possible neighbors
* theta
    + the nonlinear tuning parameter (for use with S-maps) that adjusts how distance is factored into computation of the local linear map (`0` corresponds to a globally linear map, while values greater than 0 correspond to nonlinear models where the local linear map changes as a function of state-space)
* stats_only
    + `TRUE` (default) or `FALSE`: specifies whether the output should just contain statistics of the predictions, or also contain all the predictions that were made
* exclusion_radius
    + `exclusion_radius` sets the threshold whereby all vectors with time indices too close to the predictee will be excluded from being considered nearest neighbors
    + e.g., `1` means that vectors must have an associated time index more than 1 away from potential nearest neighbors
    + by default, exclusion_radius is set to NULL (turning this filtering off)
* epsilon
    + `epsilon` sets the threshold whereby all vectors with distance too far away from the predictee will be excluded from being considered nearest neighbors
    + e.g., `2` means that vectors must have be within a distance of 2 from potential nearest neighbors
    + by default, epsilon is set to NULL (turning this filtering off)
* silent
    + `TRUE` or `FALSE` (default): specifies whether to suppress warning messages from being printed to the R console
* save_smap_coefficients
    + `TRUE` or `FALSE` (default): specifies whether to include a table of s-map coefficients with the output
    + (note that setting this to `TRUE` forces the full output as if `stats_only = FALSE`)

## Simplex Projection

**Simplex Projection** is a nearest neighbor forecasting method. It is typically applied as a simple test for estimating the optimal *embedding dimension* for a time-series. We demonstrate this in the following example.  

First, we load the data and run simplex projection. Note that we let many of the parameters to the `simplex` function be default values (e.g., $\tau = 1$, $\text{tp} = 1$). In addition, the default values for the embedding dimension, $E$, range from $1$ to $10$, and so the output will allow us to determine which embedding dimension best unfolds the attractor (i.e., resolves singularities in the dynamics to produce the best forecast skill).

```{r}
library(rEDM)
data(sockeye_returns)
ts <- sockeye_returns$returns_1d

simplex_output <- simplex(ts, lib = sockeye_lib, pred = sockeye_lib)
```

The results are a simple data.frame with columns for each of the model parameters, and forecast statistics, and rows for each run of the model. In this case, there is one run for each value of $E$, so we can simply plot $E$ against the $\rho$, the correlation between observed and predicted values:

```{r}
par(mar = c(4,4,1,1))
plot(simplex_output$E, simplex_output$rho, type = "l", 
     xlab = "Embedding Dimension (E)", ylab = "Forecast Skill (rho)")
```

## S-map

**S-map** is a forecasting method that also relies on the principle of attractor reconstruction. However, it has a nonlinear tuning parameter, $\theta$, that affects how weights change with distance in state space. By varying $theta$, it is possible to compare equivalent linear and nonlinear models. Thus, it is typically applied as a test for nonlinear dynamics after using **simplex projection** to first estimate the optimal *embedding dimension* for a time-series. We demonstrate this in the following example.  

Following from the previous example, we set `E = 2` based on the results from simplex projection. Again, note that we let many of the parameters to the `s_map` function be default values (e.g., $\tau = 1$, $\text{tp} = 1$). If these were changed in simplex projection, we would propagate those changes here. Here, we can use the default values for the nonlinear tuning parameter, $\theta$, which vary from $0$ to $8$.

```{r}
smap_output <- s_map(ts, E = 3, lib = sockeye_lib, pred = sockeye_lib)
```

Again, the results are a simple data.frame with columns for each of the model parameters, and forecast statistics, and rows for each run of the model. In this case, there is one run for each value of $\theta$, so we can simply plot $\theta$ against the $\rho$:

```{r}
par(mar = c(4,4,1,1))
plot(smap_output$theta, smap_output$rho, type = "l", 
     xlab = "Nonlinearity (theta)", ylab = "Forecast Skill (rho)")
```

## Multivariate Models

Instead of creating an attractor by taking lags of a single time series, it is possible to combine lags from different time series, as long as they are all observed from the same system. Here, forecasts can be made using the `block_lnlp` function, which can be set to use either of the **simplex projection** or **s-map** algorithms.

For `block_lnlp`, the main data input is expected to be a matrix or data.frame of the time series observations, where each column is a separate time series and each row is a set of observations at the same time. In addition to the typical arguments for `simplex` or `s_map`, `block_lnlp` contains arguments to specify which column is to be forecast (the `target_column` argument) as well as which columns to use to construct the attractor (the `columns` argument). In both cases, either a numerical index or the column name can be given. 

Note that if lagged coordinates are intended to be used, they need to be manually created as separate columns in the matrix or data.frame.

```{r}
data(block_3sp)
block_lnlp_output <- block_lnlp(block_3sp, 
                                columns = c(1,2,4), target_column = 1, 
                                stats_only = FALSE, first_column_time = TRUE)
```

By setting `stats_only` to `FALSE`, we get back a list with the full model output. Only 1 model was run, so we access the first element of the list to get the output associated with that model. Here, we can plot the observed vs. predicted to see how well the model fit relative to the expected 1:1 line.

```{r}
par(mar = c(4,4,1,1))
plot(block_lnlp_output[[1]]$model_output$obs, block_lnlp_output[[1]]$model_output$pred, 
     xlab = "Observed", ylab = "Predicted")
abline(a = 0, b = 1, lty = 2, col = "blue")
```

## Convergent Cross Mapping

**Convergent Cross Mapping** (**CCM**) is a technique to identify causality based on the idea of attractor reconstruction. In essence, if $x$ has a causal influence on $y$, then the reconstructions based on $x$ and $y$ should map diffeomorphic, and there should be a mapping from the reconstruction based on $y$ to the reconstruction based on $x$. Furthermore, this reconstruction should improve with longer time series, and so convergence of the cross mapping skill with more data is a useful property to identify.

The `ccm` function computes statistics for the cross mapping relationship, and has several additional parameters for sampling library portions to determine convergence. Please see the documentation for `ccm` for more details.

```{r}
data(sardine_anchovy_sst)
anchovy_xmap_sst <- ccm(sardine_anchovy_sst, E = 3, 
                            lib_column = "anchovy", target_column = "np_sst", 
                            lib_sizes = seq(10, 80, by = 10), num_samples = 100, 
                            silent = TRUE)
sst_xmap_anchovy <- ccm(sardine_anchovy_sst, E = 3, 
                            lib_column = "np_sst", target_column = "anchovy", 
                            lib_sizes = seq(10, 80, by = 10), num_samples = 100, 
                            silent = TRUE)
```

The output from CCM is a data.frame with statistics for each library used. Because we cross map using multiple libraries at each library size, we'd like to aggregate the results and plot the average cross map skill at each library size. Because average cross map skill less than $0$ is noninformative, we filter out negative values when plotting.

```{r, warning=FALSE}
a_xmap_t_means <- ccm_means(anchovy_xmap_sst)
t_xmap_a_means <- ccm_means(sst_xmap_anchovy)

par(mar = c(4,4,1,1))
plot(a_xmap_t_means$lib_size, pmax(0, a_xmap_t_means$rho), type = "l", col = "darkolivegreen", 
     xlab = "Library Size", ylab = "Cross Map Skill (rho)", ylim = c(0, 0.4))
lines(t_xmap_a_means$lib_size, pmax(0, t_xmap_a_means$rho), col = "blue")
legend(x = "topleft", legend = c("anchovy xmap SST", "SST xmap anchovy"), 
       col = c("darkolivegreen", "blue"), lwd = 1, inset = 0.02)
```

